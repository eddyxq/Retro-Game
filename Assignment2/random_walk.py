"""
Algorithm carves out players path
Then platforms will be generated using the path
Therefore all platforms will be reachable

ASSUMPTIONS:
    Assuming this is a vertially scrolling game
    Assuming the goal will be at the top
    Assuming player starts at the bottom
    Assuming player has jump height of 2 and horizontal movement range of 1


LIMITATIONS:
    Does not work well with wider maps
    Works best with taller maps
    Coin placement isn't the best since it randomly places coins on platforms instead of hard to reach/isolated platforms
    Coin placement is not uniformly distributed since it is random

"""

import random

# Randomly generate seed
seed = random.random()


# World size
world_width = 20
world_height = 20

# Maximum number of iterations for random_walk to find a path. (70% of total world size)
run_count = int(world_width * world_height * 0.7)


# Fill world 2D array with spaces
world = [[" " for i in range(world_width)] for j in range(world_height)]

# Player velocities
# Player moves 1 in horizontal axis and 2 in vertical
player_x = 1
player_y = 2


# Ascii characters used to represent world objects
player = "P"
platform = "T"
coin = "$"
lvl_exit = "E"

# Player's positional values
player_pos = ()             # Players position while pathfinding
starting_pos = ()           # Player's starting position
all_positions = []          # All positions visited by the player
highest_y = ()              # Tuple containing the lowest y value reached by random walk and the index of that player position in all positions
last_pos = ()               # Player's previous position Used to make sure the next random position is not the same as old
                            


# Counter to check how many times random walk reaches the top most valid location (row = 1)
# When the algorithm reaches top 3 times it stops looking for next position
# I decided on 3 because of the output results I was getting. Top most platforms are not too long or too short
reached_top = 0


# Set this to false if you do not want to erase the player's previous positions in the output
# For debug only
erase_last = False


# Updates world with new player postion generated by random_walk
# Checks to see if the new position is the top of the world, if so increment counter 
def update_world():
    global reached_top

    if erase_last: world[last_pos[1]][last_pos[0]] = " "
    else: world[last_pos[1]][last_pos[0]] = "X"
    
    world[player_pos[1]][player_pos[0]] = player
    if player_pos[1] == 1: reached_top +=1


# Displays the world
def show_world():
    for row in range(world_height):
        for col in range(world_width):
            # if col == 0:
            #     print(row, end='')
            #     continue
            print(world[row][col], end='')

        print()


#  0 means do not change
#  1 means move right for x and move down for y
# -1 means move left for x and move up for y
# 
# This function randomly generates -1, 0, or 1 to change the x and y coordinates of the player and find its next position
# Keeps looking for new positions as long as the proposed position is not outside the world's edges
# And is not in the newest 50% of all positions found
def random_walk():
    global player_pos, last_pos, highest_y, reached_top

    valid_move = False
    current_pos = player_pos
    # print("Cur position: (%d , %d)" % (player_pos[0], player_pos[1]))

    # Trap counter to account for algorithm being trapped
    # The algorithm sometimes traps itself because of the "And is not in the newest 50% of all positions found" restriction
    # So my solution was to put the player at an already visited position with the lowest y value (position closest to the top of the world)
    # And then resume the algorithm and bypass trap
    # next issue was algorithm trapping itself at the top of the world
    # The internal trap counter keeps track of the number of times the algorithm got trapped after chaning position to the top
    # if the internal trap counter goes over 30 (total 45 trap calls in one random walk function call) then it increments reached top counter to get closer to exit condition
    trap_counter = 0
    internal_trap = 0

    while(not valid_move):
        
        if trap_counter > 15:
            # print("TRAPPED")
            player_pos = all_positions[highest_y[1]]
            internal_trap += 1

            if internal_trap > 30: 
                # print("Internal trap count exceeded")
                reached_top += 1
                return

        trap_counter += 1

        # Good success 1212 good seed. betteer for square/wider maps
        # player_move_x = defined_random(45, 10) 
        # player_move_y = defined_random(20, 60)
        
        # Good seed 1621 better for taller levels??
        # player_move_x = defined_random(45, 10)
        # player_move_y = defined_random(30, 50)

        player_move_x = defined_random(45, 10)
        player_move_y = defined_random(30, 50)

        # new values are (current value + (velocity * (-1, 0 or 1)))
        new_x = player_pos[0] + (player_move_x*player_x)
        new_y = player_pos[1] + (player_move_y*player_y)


        
        # if the new x and y values are out of bounds, set valid move to false and retry finding a new position
        if (new_x <= 0 or new_x >= world_width) or (new_y <= 0 or new_y > world_height-1):
            valid_move = False
            continue

        # new position cannot be a position that is in the newest 50% of all positions  
        if len(all_positions) > 4 and (new_x, new_y) in all_positions[int(len(all_positions)/2):]:
            valid_move = False
            continue
        
        valid_move = True

    
    last_pos = current_pos
    player_pos = (new_x, new_y)

    # Check if the new position is higher than the previous highest position
    # If so update highest_y with new y value and the all_platforms array index containing it's position
    if (new_y < highest_y[0]):
        highest_y = (new_y, len(all_positions))
        # print("Highest y:" + str(highest_y))

    all_positions.append(player_pos) # Add the new position to all positions
    # print("trap counter:", trap_counter)


    # print("\nNew position: (%d , %d)" % (player_pos[0], player_pos[1]))


# Randomizer that takes in 2 values, Chance to get -1 and change to get 0 and computes the chance to get 1
# Generates a random number from 0-100
# if the number is less than chance to get -1 then return -1
# if the number is greater than chance to get -1 but less than (chance to get -1  + chance to get 0) then return 0
# otherwise return 1
def defined_random(neg_one_chance, zero_chance):
    num = random.randint(0, 100)
    if num < neg_one_chance:
        return -1

    elif num >= neg_one_chance and num < (neg_one_chance + zero_chance):
        return 0

    else: return 1

# function to test the results of random functions
# Debug code
def check_random():
    count_0 = 0
    count_1 = 0
    count = 0 # count -1
    for i in range(100):
        res = defined_random(45, 10)
        if (res == 0): 
            count_0 += 1
        elif (res == 1):
            count_1 += 1
        else:
            count += 1

    print("Percent vals: (-1, 0, 1):  %d %d %d" % (count, count_0, count_1))

# starting position of player
# -1: bottom left
#  0: bottom center
#  1: bottom right 
# Randomly genrate -1, 0 or 1 and depending on the number start the random walk function at the corresponding position
# Then initalize positional values 
def get_starting_pos():
    global player_pos, last_pos, all_positions, highest_y, starting_pos
    res = random.randint(-1, 0)
    if res == -1:
        print("LEFT START")
        player_pos = (1, world_height-3)
    elif res == 0:
        print("MID START")
        player_pos = (int(world_width/2), world_height-3)
    else:
        print("RIGHT START")
        player_pos = (world_width-1, world_height-3)

    last_pos = player_pos
    all_positions = [player_pos]
    highest_y = (player_pos[1], 0)
    starting_pos = player_pos

# Creates the level from the path created by random walk
# Turns all Xs to platforms
# puts Exit character E on top of P which is at the top of the board 
# has a 10% chance to placing a coin on any platform
# finally, puts a "P" at the row above player's starting position
def create_level():
    for row in range(world_height):
        for col in range(world_width):
            if world[row][col] == "X":
                world[row][col] = platform

                if (random.randint(0, 100) < 10):
                    world[row-1][col] = coin

            if world[row][col] == player:
                world[row][col] = platform
                world[row-1][col] = lvl_exit

    world[starting_pos[1]-1][starting_pos[0]] = player


def main():    
    random.seed(seed)

    loop_count = 0
    get_starting_pos() # initialize starting values

    while(loop_count < run_count and reached_top < 5):
        update_world() # update world with starting values and new values created by random walk
        random_walk() # find the next position for the player to move to
        loop_count += 1



    print("Seed: " + str(seed))
    print("max run count: ", run_count)
    print("actual run count:", loop_count)
    print()

    
    print("\n LEVEL GENERATION \n")
    create_level()
    show_world()

        

main()